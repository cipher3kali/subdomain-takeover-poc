Model

dbsetup

const collection = require('../utilities/connection');

//dummy user data
const userDb = [
    
    {
        wishlist: ["P1001"],
        name: "admin",
        emailId: "admin@gmail.com",
        contactNo: 1234567890,
        city: "Mysore",
        area: "Hebbal",
        pincode: 123457,
        password: "$2a$10$t3G7ylhyl.hGMLURG1L0J.MESNr..BMBYHacOZBLrygtOnLW1.ROO",
        userId: "U1001"
    },
    {
        wishlist: ["P1001", "P1002"],
        name: "user",
        emailId: "user@gmail.com",
        contactNo: 9874567890,
        city: "Mysore",
        area: "Hebbal",
        pincode: 123457,
        password: "$2a$10$pmoeOnb8HTmuDy6tgwFDuuoiHZoC9m0ZN/k7YF0nC7Ix.ZxAcbj5q",
        userId: "U1002"
    },
    {
        wishlist: ["P1003", "P1004"],
        name: "rachana",
        emailId: "rach@gmail.com",
        contactNo: 9870267878,
        city: "Mysore",
        area: "Krishna Rajendra Circle",
        pincode: 570017,
        password: "$2a$10$LvMi9eJUTMfkGTl6X7dUje5/YN8.pfGt3oSkoM3piuT0TjHNvXowO",
        userId: "U1003"
    },
    {
        wishlist: ["P1005", "P1006"],
        name: "shreedhevi",
        emailId: "rach1234@gmail.com",
        contactNo: 9364829408,
        city: "Mysore",
        area: "Krishna Rajendra Circle",
        pincode: 570001,
        password: "$2a$10$6VshH3BY5/W5Lo8Nl9hXCeeBovCaKLLJ9YeuDVasBRPupBavuKaXS",
        userId: "U1004"
    },
    {
        wishlist: ["P1001"],
        name: "naman",
        emailId: "naman@gmail.com",
        contactNo: 7234567890,
        city: "Mysore",
        area: "Hebbal",
        pincode: 123457,
        password: "$2a$10$4/ELqYFRpp6F4eLDUE9sWO3ctY.Eo9oTvptsm4/Vyn5rvdnobJ8PO",
        userId: "U1005"
    }
]

//dummy role data
const roleDb =
{
    registeredUsers: ["U1002"],
    buyers: ["U1002"],
    sellers: ["U1001"]
}

//dummy data for property
const propertyDb = [
    {
        // ids
        propertyId: "P1001",
        sellerId: "U1001",
        buyerId: "U1003",
        pincode: 570001,
        area:"Mandimohalla",
        // features
        propertyType: "Rent",
        propertyOwnership: "Owner",
        buildingType: "House",
        noOfBathrooms: 2,
        noOfBedrooms: 2,
        noOfBalconies: 1,
        furnishing: "Fully Furnished",
        availability: "Ready to move",
        // amenities
        lifts: true,
        ac: true,
        heater: false,
        maintenenceStaff: true,
        visitorParking: true,
        IntercomFacility: false,
        wifi: true,
        fireAlarm: false,
        WaterPurifier: false,
        PowerBackup: true,
        // highlights
        WaterSupplyFor24Hours: true,
        CloseToSchool: true,
        CloseToHospital: false,
        CloseToRailwayStation: true,
        CloseToBusStand: true,
        CloseToAirport: false,
        CloseToBank: true,
        CloseToPark: false,
        // other details
        status: "Available",
        Address: "196,12th Street",
        price: 15000,
        Advance: 50000,
        transactionType: "New",
        ageOfProperty: "1 year old property",
        availabilityBy: "Within 2 weeks",
        totalFloors: 10,
        PropertyFloor: 5,
        propertyArea: 1200,
        poojaRoom: true,
        servantRoonm: true,
        noofCoveredParking: 1,
        noOfOpenParking: 1,
        // description: "Recently renovated and restored. Upper Unit - 2 Bedrooms 2 Full Bathroom - New kitchen, appliances, bathroom and flooring - Kitchen appliances included: Refrigerator, Gas Oven/ Range, Dishwasher, Over the Range Microwave - Private Washer and Dryer - 2 driveway parking spaces - All Bedrooms have large closets - 2 minute walk from village center: Restaurants, cafes, shops, bars, festivals, farmers market - Tenant pays Gas and Electricity - Available Immediately - Sorry, no pets Tenant pays gas and electricity",
        imageUrls: "../../../assets/tiny-house-1.jpg",
        extras: "Pets are not allowed",
        status_wishlist: false
    },

    {        // ids
        propertyId: "P1002",
        area:"Mandimohalla",
        sellerId: "U1002",
        buyerId: "U1006",
        pincode: 570016,
        // features
        propertyType: "Sale",
        propertyOwnership: "Owner",
        buildingType: "House",
        noOfBathrooms: 2,
        noOfBedrooms: 3,
        noOfBalconies: 2,
        furnishing: "Fully Furnished",
        availability: "Ready to move",
        // amenities
        lifts: true,
        ac: true,
        heater: false,
        maintenenceStaff: true,
        visitorParking: true,
        IntercomFacility: false,
        wifi: true,
        fireAlarm: false,
        WaterPurifier: false,
        PowerBackup: true,
        // highlights
        WaterSupplyFor24Hours: true,
        CloseToSchool: true,
        CloseToHospital: false,
        CloseToRailwayStation: true,
        CloseToBusStand: true,
        CloseToAirport: false,
        CloseToBank: true,
        CloseToPark: false,
        // other details
        status: "Available",
        Address: "197,2nd Street",
        price: 1200000,
        Advance: 50000,
        transactionType: "New",
        ageOfProperty: "1 year old property",
        availabilityBy: "Within 2 weeks",
        totalFloors: 10,
        PropertyFloor: 5,
        propertyArea: 1800,
        poojaRoom: true,
        servantRoonm: true,
        noofCoveredParking: 1,
        noOfOpenParking: 1,
        // description: "Recently renovated and restored. Upper Unit - 2 Bedrooms 2 Full Bathroom - New kitchen, appliances, bathroom and flooring - Kitchen appliances included: Refrigerator, Gas Oven/ Range, Dishwasher, Over the Range Microwave - Private Washer and Dryer - 2 driveway parking spaces - All Bedrooms have large closets - 2 minute walk from village center: Restaurants, cafes, shops, bars, festivals, farmers market - Tenant pays Gas and Electricity - Available Immediately - Sorry, no pets Tenant pays gas and electricity",
        imageUrls: "../../../assets/tiny-house-2.jpg",
        extras: "Pets are not allowed",
        status_wishlist: false
    },
    {
        // ids
        propertyId: "P1003",
        sellerId: "U1003",
        buyerId: "U1009",
        pincode: 570016,
        area:"Krishna Rajendra Circle",
        // features
        propertyType: "Sale",
        propertyOwnership: "Owner",
        buildingType: "House",
        noOfBathrooms: 2,
        noOfBedrooms: 2,
        noOfBalconies: 1,
        furnishing: "Fully Furnished",
        availability: "Ready to move",
        // amenities
        lifts: true,
        ac: true,
        heater: false,
        maintenenceStaff: true,
        visitorParking: true,
        IntercomFacility: false,
        wifi: true,
        fireAlarm: false,
        WaterPurifier: false,
        PowerBackup: true,
        // highlights
        WaterSupplyFor24Hours: true,
        CloseToSchool: true,
        CloseToHospital: false,
        CloseToRailwayStation: true,
        CloseToBusStand: true,
        CloseToAirport: false,
        CloseToBank: true,
        CloseToPark: false,
        // other details
        status: "Available",
        Address: "19,4th Street",
        price: 1200000,
        Advance: 50000,
        transactionType: "New",
        ageOfProperty: "1 year old property",
        availabilityBy: "Within 2 weeks",
        totalFloors: 10,
        PropertyFloor: 5,
        propertyArea: 1000,
        poojaRoom: true,
        servantRoonm: true,
        noofCoveredParking: 1,
        noOfOpenParking: 1,
        // description: "Recently renovated and restored. Upper Unit - 2 Bedrooms 2 Full Bathroom - New kitchen, appliances, bathroom and flooring - Kitchen appliances included: Refrigerator, Gas Oven/ Range, Dishwasher, Over the Range Microwave - Private Washer and Dryer - 2 driveway parking spaces - All Bedrooms have large closets - 2 minute walk from village center: Restaurants, cafes, shops, bars, festivals, farmers market - Tenant pays Gas and Electricity - Available Immediately - Sorry, no pets Tenant pays gas and electricity",
        imageUrls: "../../../assets/tiny-house-3.jpg",
        extras: "Pets are not allowed",
        status_wishlist: false
    },
    {
        // ids
        propertyId: "P1004",
        sellerId: "U1004",
        buyerId: "U1012",
        pincode: 570017,
        area:"Krishna Rajendra Circle",
        // features
        propertyType: "Rent",
        propertyOwnership: "Owner",
        buildingType: "House",
        noOfBathrooms: 2,
        noOfBedrooms: 2,
        noOfBalconies: 1,
        furnishing: "Fully Furnished",
        availability: "Ready to move",
        // amenities
        lifts: true,
        ac: true,
        heater: false,
        maintenenceStaff: true,
        visitorParking: true,
        IntercomFacility: false,
        wifi: true,
        fireAlarm: false,
        WaterPurifier: false,
        PowerBackup: true,
        // highlights
        WaterSupplyFor24Hours: true,
        CloseToSchool: true,
        CloseToHospital: false,
        CloseToRailwayStation: true,
        CloseToBusStand: true,
        CloseToAirport: false,
        CloseToBank: true,
        CloseToPark: false,
        // other details
        status: "Available",
        Address: "19,8th Street",
        price: 8000,
        Advance: 50000,
        transactionType: "New",
        ageOfProperty: "1 year old property",
        availabilityBy: "Within 2 weeks",
        totalFloors: 10,
        PropertyFloor: 5,
        propertyArea: 1000,
        poojaRoom: true,
        servantRoonm: true,
        noofCoveredParking: 1,
        noOfOpenParking: 1,
        // description: "Recently renovated and restored. Upper Unit - 2 Bedrooms 2 Full Bathroom - New kitchen, appliances, bathroom and flooring - Kitchen appliances included: Refrigerator, Gas Oven/ Range, Dishwasher, Over the Range Microwave - Private Washer and Dryer - 2 driveway parking spaces - All Bedrooms have large closets - 2 minute walk from village center: Restaurants, cafes, shops, bars, festivals, farmers market - Tenant pays Gas and Electricity - Available Immediately - Sorry, no pets Tenant pays gas and electricity",
        imageUrls: "../../../assets/tiny-house-4.jpg",
        extras: "Pets are not allowed",
        status_wishlist: false
    }
   
]

//location Collection
const locationDb = [
    {
        "propertyIds": ["P1001", "P1002"],
        "pincode": 570001,
        "area": "Mandimohalla",
        "city": "Mysore",
        "state": "KARNATAKA"
    },
    {
        "propertyIds": ["P1003", "P1004"],
        "pincode": 570001,
        "area": "Krishna Rajendra Circle",
        "city": "Mysore",
        "state": "KARNATAKA"
    },
    {
        "propertyIds": ["P1005", "P1006"],
        "pincode": 570001,
        "area": "Mysore",
        "city": "Mysuru",
        "state": "KARNATAKA"
    },
    {
        "pincode": 570002,
        "area": "Vani Vilas Mohalla",
        "city": "Mysore",
        "state": "KARNATAKA"
    }
]

exports.setupDb = () => {
    return collection.getUserCollection().then((user) => {
        return user.deleteMany().then(() => {
            return user.insertMany(userDb).then(() => {
                return collection.getLocationCollection().then((location) => {
                    return location.deleteMany().then(() => {
                        return location.insertMany(locationDb).then(() => {
                            return collection.getRoleCollection().then((role) => {
                                return role.deleteMany().then(() => {
                                    return role.insertMany(roleDb).then(() => {
                                        return collection.getPropertyCollection().then((property) => {
                                            return property.deleteMany().then(() => {
                                                return property.insertMany(propertyDb).then((data) => {
                                                    if (data) return "Insertion Successfull"
                                                    else {
                                                        let err = new Error("Insertion failed");
                                                        err.status = 400;
                                                        throw err;
                                                    }
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    })
}

Property.js

class property{
    constructor(obj){
       this.propertyId= obj.propertyId;
       this.sellerId= obj.sellerId;
       this.buyerId=obj.buyerId ;
       this.pincode= obj.pincode;
       this.propertyType= obj.propertyType;
       this.propertyOwnership= obj.propertyOwnership;
       this.buildingType=obj.buildingType;
       this.noOfBathrooms= obj.noOfBathrooms;
       this.noOfBedrooms=obj.noOfBedrooms;
       this.noOfBalconies= obj.noOfBalconies;
       this.availability=obj.availability;
    // amenities
    this.lifts= obj.lifts;
    this.ac= obj.ac;
    this.heater=obj.heater;
    this.maintenenceStaff=obj.maintenenceStaff;
    this.visitorParking= obj.visitorParking;
    this.IntercomFacility= obj.IntercomFacility;
    this.wifi=obj.wifi;
    this.fireAlarm=obj. fireAlarm;
    this.WaterPurifier=obj. WaterPurifier;
    this.PowerBackup= obj.PowerBackup;
    // highlights
 this.WaterSupplyFor24Hours=obj. WaterSupplyFor24Hours;
    this.CloseToSchool= obj.CloseToSchool;
    this.CloseToHospital= obj.CloseToHospital;
    this.CloseToRailwayStation= obj.CloseToRailwayStation;
    this.CloseToBusStand= obj.CloseToBusStand;
    this.CloseToAirport= obj.CloseToAirport;
    this.CloseToBank=obj.CloseToBank;
    this.CloseToPark= obj.CloseToPark;
    // other details
    this.status=obj.status;
    this.Address= obj.Address;
    this.price=obj.price;
    this.Advance= obj.Advance;
    this.transactionType= obj.transactionType;
    this.ageOfProperty= obj.ageOfProperty;
    this.availabilityBy= obj.availabilityBy;
    this.totalFloors=obj.totalFloors;
    this.PropertyFloor=obj.PropertyFloor;
    this.propertyArea= obj.propertyArea;
    this.poojaRoom= obj.poojaRoom;
    this.servantRoonm= obj.servantRoonm;
    this.noofCoveredParking=obj.noofCoveredParking;
    this.noOfOpenParking=obj.noOfOpenParking;
    this.description= obj.description;
    this.imageUrls=obj.imageUrls;
    this.extras=obj.extras;

    }
}
module.exports=property

User.js

class user{
    constructor(obj){
       this.userId=obj.userId
        this.name=obj.name
        this.emailId= obj.emailId
        this.contactNo=obj.contactNo
        this.city=obj.city
        this.area= obj.area
        this.pincode= obj.pincode
        this.password= obj.password
        this.wishlist=obj.wishlist;

    }
}
module.exports=user

UserModel.js

const dbModel = require( '../utilities/connection' );
const userModel = {}
//To generate userId for new User
userModel.generateId = () => {
    return dbModel.getUserCollection().then( ( userModel ) => {
        return userModel.distinct( "userId" ).then( ( ids ) => {
            let idarr = ids.map( ( data ) => { return Number( data.slice( 1 ) ) } )
            let bId = Math.max( ...idarr );
            return"U" + ( bId + 1 );
        } )
    } )
}

//to generate property id for every new property
userModel.generatePropertyId=()=>{
    return dbModel.getPropertyCollection().then((propertyModel)=>{
        return propertyModel.distinct("propertyId").then((ids)=>{
            let idarr = ids.map( ( data ) => { return Number( data.slice( 1 ) ) } )
            let bId = Math.max( ...idarr );
            return"P" + ( bId + 1 );

        })
    })
}

//To check whether the user with conatctNo or emailId exist or not
userModel.findUser = ( emailId)=> {   
    return dbModel.getUserCollection().then( model => {       
        return model.findOne({"emailId": emailId}).then( ( userData )=>{
            
            if( userData===null ){
                return null;
            } else{               
                return userData;
            }
        } )
    } )
}

//to search the location for property
userModel.searchLocation=()=>{
    return dbModel.getLocationCollection().then( model => {
        return model.find().then((location)=>{
            if( location==null ){
                return null;
            } else{               
                return location;
            }
        })

    })
}

//to accept user details and save it to database
userModel.addUser=(UserObj)=>{
    return dbModel.getUserCollection().then(data=>{       
        return data.create(UserObj).then(added=>{
            if(added){              
                return added
            }else{
                let err=new Error("User not registered")
                err.status=404
                throw err
            }
        })
    })
}

//to fetch the user details from database
userModel.searchUser = ( userId )=> {
    return dbModel.getUserCollection().then( model => {
        return model.findOne( {"userId": userId},{wishlist:1,_id:0} ).then( ( userData )=>{
            if( userData.wishlist.length < 1 ){
                return null
            } else{
                return userData.wishlist;
            }
        } )
    } )
}

//delete data when admin clicks delete
userModel.deleteUser=(userId)=>{
    return dbModel.getUserCollection().then(model=>{
        return model.deleteOne({"userId":userId}).then(data=>{
            if(data){
                return dbModel.getPropertyCollection().then(model1=>{
                    return model1.deleteOne({"sellerId":userId}).then(deleted=>{
                        if(deleted.nModified>0){
                            return userId
                        }else{
                            return null
                        }
                    })
                })
            }
        })
        })
}

//to find the property with respect to location
userModel.findProperty=()=>{
    return dbModel.getPropertyCollection().then(model=>{
        return model.find().then(property_Data=>{
            if(property_Data) return property_Data
            else return null
        })
    })
}
//view the selected property
userModel.viewProperty=(propertyId)=>{
    return dbModel.getPropertyCollection().then(model=>{
        return model.findOne({"propertyId":propertyId}).then(property_Data=>{
            if(property_Data) return property_Data
            else return null
        })
    })
}

//get all registered users from the userdb
userModel.getallUsers=()=>{
    return dbModel.getUserCollection().then(model=>{
        return model.find().then(user_data=>{
           
            if(user_data){
                return user_data
            }else{
                return null
            }
        })
    })
}
//to get property table and delete on click
userModel.deleteUserp=(propertyId)=>{
    return dbModel.getPropertyCollection().then(model=>{
        return model.deleteOne({"propertyId":propertyId}).then(data=>{
           
            if(data){
                return propertyId
            }else{
                return null
            }
        })
        })
}

//to display user profile  and display the posted properties
userModel.profile=(userId)=>{
    return dbModel.getPropertyCollection().then(model=>{
        return model.find({"sellerId":userId}).then(data=>{
            if(data){
                return data
            }else{
                return null
            }
        })
    })
}

//to add a new property to the property db
userModel.addPropertyDetails=(propertyObj)=>{
    return dbModel.getPropertyCollection().then(model=>{
        return model.create(propertyObj).then(data=>{
            if(data){
                return data
            }else{
                return null
            }
        })
    })
}

// to update the registered user,seller,buyer details
userModel.updateRoleSellerSchema=(userId)=>{
    return dbModel.getRoleCollection().then(model=>{
        return model.updateOne({},{$push:{sellers:userId}}).then(data=>{
            if(data.nModified==1){
                return data
            }else{
                return null
            }
        })
    })
}


//to get buyers from the buyers array in roledb
userModel.buyersget=()=>{
    return dbModel.getRoleCollection().then(model=>{       
        return model.findOne({},{buyers:1,_id:0}).then(buyers1=>{
            if(buyers1){              
                return dbModel.getUserCollection().then(model=>{
                    return model.find({"userId":{$in:buyers1.buyers}}).then(data=>{
                        if(data){                        
                            return data
                        }else{
                            return null
                        }
                    })

                })
                
            }else{
                return null
            }
        })
    })
}

//to get sellers form the roledb array and view it in the admin profile
userModel.sellersget=()=>{
    return dbModel.getRoleCollection().then(model=>{       
        return model.findOne({},{sellers:1,_id:0}).then(sellers=>{
            if(sellers){              
                return dbModel.getUserCollection().then(model=>{
                    return model.find({"userId":{$in:sellers.sellers}}).then(data=>{
                        if(data){                           
                            return data
                        }else{
                            return null
                        }
                    })

                })
                
            }else{
                return null
            }
        })
    })
}

//to get wishlisted items from the wishlst array of a user form userdb
userModel.getWishlist=(userId)=>{
    return dbModel.getUserCollection().then(model=>{
        return model.findOne({"userId":userId},{wishlist:1,_id:0}).then(data=>{
            if(data!=null){
                return dbModel.getPropertyCollection().then(model=>{
                    return model.find({propertyId:{$in:data.wishlist}}).then(list=>{
                        if(list.length>0){
                            return list
                        }else{
                            return null
                        }
                    })
                })
            }else{
                return null
            }
        })
    })
}

//to add a property to the wishlist array 
userModel.addWish=(uid,pid,status)=>{
    return dbModel.getUserCollection().then(model=>{
        if(status==true){
            return model.findOne({"userId":uid}).then(res1=>{
                if(res1.wishlist.find(p=>p==pid)){
                    return "Already in wishlist"
                }else{
                    return model.updateOne({"userId":uid},{$push:{wishlist:pid}}).then(data=>{
                        if(data.nModified>0){
                            return "Successfully added your property"
                        }else{
                            return null
                        }
                    })
                }
            })
        }else{
            return model.updateOne({"userId":uid},{$pull:{wishlist:pid}}).then(data=>{
                if(data.nModified>0){
                    return "Successfully removed from wishlist"
                }else{
                    return "No such property"
                }
            })
        }
    })
}
userModel.update_p=(name,contact_no,userId)=>{
    return dbModel.getUserCollection().then(model=>{       
        return model.updateOne({"userId":userId},{$set:{'name':name,'contactNo':contact_no}}).then(updated=>{
            if(updated.nModified>0){
                return updated
            }else{
                return null
            }
        })
    })
}

//to add new sellers to role db
userModel.seller_role=(userId)=>{
    return dbModel.getRoleCollection().then(model=>{
        return model.updateOne({$push:{"sellers":userId}}).then(added=>{
            if(added.nModified>0){
                return added
            }else{
                return null
            }
        })
    })
}
module.exports = userModel;

Routing.js

const express = require('express');
const router = express.Router();
const userService = require('../service/userService');
var bodyParser = require('body-parser');
const Property =require('../model/property');
const registerService = require('../service/registerService');
const loginService = require('../service/loginService');


router.use(bodyParser.urlencoded({ extended: false }));
router.use(bodyParser.json());



//For Registering the user
router.post('/register',function(req,res,next){  
     
    let userObj=req.body    
   
    registerService.addDetails(userObj).then(result=>{
       res.json(result)
   }).catch(err=>next(err));
})



//Login for user and Admin
router.post('/login', function (req, res, next) {    
    let emailId = req.body.emailId;
    let password = req.body.password;
    
    loginService.checkUser(emailId, password).then(result => {
     
        res.json(result);
    }).catch(err => next(err));
})

//Routing For update Profile
router.put('/update_profile/:userId', function (req, res, next) {    
    let name = req.body.name;
    let contact_no = req.body.contactNo;
   
    userService.update_p(name, contact_no,req.params.userId).then(result => {
       
        res.json(result);
    }).catch(err => next(err));
})

//Routing for Location Searching
router.get('/search', function (req, res, next) {
   
    userService.search().then(result => {
        res.json(result);
    }).catch(err => next(err));
})

//ROuting for buy
router.get('/buy',function(req,res,next){

    userService.showProperty().then(result=>{
        res.json(result)
    }).catch(err=>next(err))
})


//Show users Profile
router.get('/profile/:userId',function(req,res,next){
    let userId=req.params.userId
    userService.profile(userId).then(val=>{
        res.json(val)
    }).catch(err=>next(err))
})


//Routing for Viewing property information
router.get('/view/:propertyId',function(req,res,next){
    userService.viewProperty(req.params.propertyId).then(result=>{
        res.json(result)
    }).catch(err=>next(err))
})



//For Admin use (delete)
router.delete('/delete/:userId',function(req,res,next){
    let userId=req.params.userId   
    userService.deleteUser(userId).then(removed=>{
        res.json({"message":"the deleted user is "+removed})
    }).catch(err=>next(err))

})

//It Show all Users (Admin)
router.get('/get',function(req,res,next){   
    userService.getallUsers().then(users=>{       
        res.send(users)
    }).catch(err=>next(err))
})

//Property Remove (Admin)
router.delete('/deletep/:propertyId',function(req,res,next){
    let propertyId=req.params.propertyId
    userService.deleteUserp(propertyId).then(removed=>{
        res.json({"message":"the deleted user is "+removed})
    }).catch(err=>next(err))

})

//Redirecting to sell Component
router.post('/sell/:userId',function(req,res,next){
    const propertyObj=new Property(req.body)
    userService.addproperty(propertyObj,req.params.userId).then(val=>{
        res.json(val)       
    }).catch(err=>next(err))
})

//Show All Buyers(Admin)
router.get('/buyers',function(req,res,next){
    userService.buyersget().then(buyers=>{
        res.json(buyers)
    }).catch(err=>next(err))
})

//Show All Sellers(Admin)
router.get('/sellers',function(req,res,next){
    userService.sellersget().then(sellers=>{
        res.json(sellers)
    }).catch(err=>next(err))
})

//Adding Item To wishlist
router.get('/update/:userId/:propertyId/:state',function(req,res,next){
    let userId=req.params.userId
    let propertyId=req.params.propertyId
    let status=req.params.state
    userService.addWish(userId,propertyId,status).then(added=>{
        res.json(added)
    }).catch(err=>next(err))
})

//Show Wishlist
router.get('/wishlist/:userId',function(req,res,next){
    let userId=req.params.userId
    return userService.getWishlist(userId).then(wishlist=>{
        res.json(wishlist)
    }).catch(err=>next(err))
})

//Adding user to role as seller
router.get('/role/:userId',function(req,res,next){
    let userId=req.params.userId
    return userService.seller_role(userId).then(added=>{
        res.json(added)
    }).catch(err=>next(err))
})

module.exports = router;

buyerService

const userdb = require('../model/userModel');
const bcrypt = require('bcryptjs')
const Validator=require('../utilities/Validators')
let buyerService = {}





module.exports = buyerService;

loginservice

const userdb = require('../model/userModel');
const bcrypt = require('bcryptjs')
const Validator=require('../utilities/Validators')
let loginService = {}

loginService.checkUser = (emailId, password) => {
    Validator.validateEmail(emailId)
    Validator.validatePassword(password)
    return userdb.findUser(emailId).then(userData => {
        if (userData == null) {
            let err = new Error("user not available!! Please register");
            err.status = 404;
            throw err;
        } else {
            if (userData.emailId === emailId) {
                // return bcrypt.compare(password, userData.password).then((res) => {
                //     if (res) {
                        return userData;
                //     } else {
                //         let err = new Error("Password is Incorrect");
                //         err.status = 404;
                //         throw err;

                //     }
                // })
            }
            else {
                let err = new Error("Authentication failed");
                err.status = 404;
                throw err;
            }

        }
    })
}
module.exports = loginService;

RegisterService.js

const userdb = require('../model/userModel');
const bcrypt = require('bcryptjs')
const Validator=require('../utilities/Validators')
let registerService = {}


registerService.addDetails = (UserObj) => {

    return userdb.findUser(UserObj.emailId, UserObj.contact).then(object => {
        {
            if (object != null) {
                let err = new Error("This EmailId and contact number already exist");
                err.status = 404;
                throw err;
            } else {
                Validator.validateEmail(UserObj.emailId)
                Validator.validateName(UserObj.name)
                Validator.validateContactNo(UserObj.contact)
                Validator.validatePassword(UserObj.password)
                bcrypt.genSalt(10, function(err, salt) {
                    bcrypt.hash(UserObj.password, salt, function(err, hash) {
                        // Store hash in your password DB.
                       UserObj.password=hash
                    });
                });  
                return userdb.generateId().then((data) => {
                    UserObj.userId = data;
                    return userdb.addUser(UserObj).then((data) => {
                        if (data) {
                            return data;
                        }
                        else {
                            let err = new Error("Authentication failed!");
                            err.status = 404;
                            throw err;
                        }
                    })
                })
            }
        }
    })

}
module.exports = registerService;

userService.js

const userdb = require('../model/userModel');
const bcrypt = require('bcryptjs')
const Validator=require('../utilities/Validators')
let infyMansionService = {}
 

//Service for Searching Location
infyMansionService.search = () => {
    return userdb.searchLocation().then(object => {
        {
            if (object == null) {
                let err = new Error("no location exists");
                err.status = 404;
                throw err;
            } else {
                return object;


            }
        }
    })
}




//to show the property with respect to location
infyMansionService.showProperty = () => {
    return userdb.findProperty().then(result => {
        if (result == null) {
            let err = new Error("No property");
            err.status = 204;
            throw err;
        } else {
            return result;
        }
    })
}

// Service for Showing the Property
infyMansionService.viewProperty = (propertyId) => {
    return userdb.viewProperty(propertyId).then(result => {
        if (result == null) {
            let err = new Error("No property");
            err.status = 204;
            throw err;
        } else {
            return result;
        }
    })
}


//To Delete The user (Admin)
infyMansionService.deleteUser = (userId) => {
    return userdb.deleteUser(userId).then(removedUser => {

        if (removedUser) {
            return removedUser
        } else {
            let err = new Error("User data not deleted")
            err.status = 502;
            throw err
        }
    })
}

// Service To Show All Users (Admin)
infyMansionService.getallUsers = () => {
    return userdb.getallUsers().then(dataUsers => {

        if (dataUsers != null) {
            return dataUsers
        } else {
            let err = new Error("No user data available")
            err.status = 404
            throw err
        }
    })
}
//To Delete Property
infyMansionService.deleteUserp = (propertyId) => {
    return userdb.deleteUserp(propertyId).then(removedUser => {
        if (removedUser) {
            return removedUser
        } else {
            let err = new Error("Unable to delete property")
            err.status = 502;
            throw err
        }
    })
}

//Service to show User Profile
infyMansionService.profile = (userId) => {
    return userdb.profile(userId).then(data => {
        if (data) {
            return data
        } else {
            let err = new Error("You have no properties")
            err.status = 404
            throw err
        }
    })
}

//Service For adding property for sell component
infyMansionService.addproperty = (propertyObj, userId) => {
    return userdb.generatePropertyId().then(data => {
        propertyObj.propertyId = data;
        let img = data.substr(4, 1)
        propertyObj.imageUrls = "../../../assets/tiny-house-" + img + ".jpg"

        propertyObj.sellerId = userId;
        return userdb.addPropertyDetails(propertyObj).then((model) => {
            if (model) {

                return userdb.updateRoleSellerSchema(userId).then(data2 => {
                    if (data2) {

                        return model
                    } else {
                        let err = new Error("Sorry! this property really exists");
                        err.status = 404;
                        throw err;

                    }
                })
            } else {
                let err = new Error("Unable to add property!Try again");
                err.status = 502;
                throw err;
            }
        })

    })
}
//Service to show all the buyers(Admin)
infyMansionService.buyersget = () => {
    return userdb.buyersget().then(buyers => {
        if (buyers) {
            return buyers
        } else {
            let err = new Error("No buyers available");
            err.status = 404;
            throw err;
        }
    })
}
//Service to get all Sellers(Admin)
infyMansionService.sellersget = () => {
    return userdb.sellersget().then(sellers => {
        if (sellers) {
            return sellers
        } else {
            let err = new Error("No sellers available");
            err.status = 404;
            throw err;
        }
    })
}

//to get wishlist
infyMansionService.getWishlist = (userId) => {
    return userdb.getWishlist(userId).then(wishlist => {
        if (wishlist != null) {
            return wishlist
        } else {
            let err = new Error("You have no items wishlisted");
            err.status = 404;
            throw err;
        }
    })
}

//to add wishlist
infyMansionService.addWish = (uid, pid, status) => {
    return userdb.addWish(uid, pid, status).then(added => {
        if (added) {
            return added
        } else {
            let err = new Error("Couldnt add to wishlist");
            err.status = 502;
            throw err;
        }
    })
}
//to update profile
infyMansionService.update_p = (name, contact_no, userId) => {
    return userdb.update_p(name, contact_no, userId).then(updated => {
        if (updated) {
            return updated
        } else {
            let err = new Error("Could not update profile");
            err.status = 502;
            throw err;
        }
    })
}

//to add new seller to role db
infyMansionService.seller_role = (userId) => {
    return userdb.seller_role(userId).then(added => {
        if (added) {
            return added
        } else {
            let err = new Error("Could not update seller details");
            err.status = 502;
            throw err;
        }
    })
}
module.exports = infyMansionService;

Connection.js

const { Schema } = require("mongoose");
const Mongoose = require("mongoose")
Mongoose.Promise = global.Promise;
Mongoose.set('useCreateIndex', true)
const url = "mongodb://localhost:27017/GoHome";
let collection = {}

//Schema For Users 
const userSchema = Schema({
    userId: {
        type: String,
        required: [true, 'Required field'],
        unique: [true, 'Id must be unique']
    },
    name: {
        type: String,
        required: [true, 'Required field'],
        match: [/^[a-zA-Z]+( )*[a-zA-Z]*( )*[a-zA-Z]+$/, 'Please enter a valid name(name should not contain space at end)']
    },
    emailId: {
        type: String,
        minLength: [8, "password should have atleast 8 characters "],
        maxLength: [20, "Password limit is 20"],
        required: [true, 'Required field'],
        unique: [true, 'Id must be unique'],
        match: [/^[a-z]+[0-9]*@[a-z]+\.([a-z]{2,3})(\.){0,1}([a-z]{0,2})$/, 'Please enter a valid email Id']
    },
    contactNo: {
        type: Number,

        required: [true, 'Required field'],

        match: [/^[6-9][0-9]{9}$/, 'Please enter a valid 10 digit phone number']
    },
    city: {
        type: String
    },
    area: String,
    pincode: {

        type: Number
       
    },
    password:{
        type: String,

        required: [true, 'Required field']

      
    },
     wishlist: []},
     { collection: "User" });


const propertySchema = Schema({
    propertyId: {
        type: String,
        unique: true
    },
    sellerId: {
        type: String,
        unique: true
    },
    buyerId: {
        type: String
        , unique: true
    },
    pincode: {
        type: Number,

        required: [true, 'Required field'],

        match: [/^[1-9]{1}[0-9]{5}$/, 'Six Digit Code allow only']
    },
    propertyType: {
        required: [true, 'Required field'],
        type: String,
        enum: ['Sale', 'Rent']
    },
    propertyOwnership: {
        required: [true, 'Required field'],
        type: String
    },
    buildingType: {
        required: [true, 'Required field'],
        type: String
    },
    noOfBathrooms: {
        required: [true, 'Required field'],
        type: Number
        , min: [1, "minimum number of Bathrooms should be 1"]
    },
    noOfBedrooms: {
        required: [true, 'Required field'],
        type: Number,
        min: [1, "minimum number of Bedrooms should be 1"]
    },
    noOfBalconies: {
        required: [true, 'Required field'],
        type: Number,
        min: [0, "number of Balconies cant be negative"]
    },
    furnishing: {
        type: String,
        maxLength: [30, "Description Should be Short"]
    },
    availability: {
        type: String,
        maxLength: [20, "Only 20 Character allow"]
    },
    // amenities
    lifts: Boolean,
    ac: Boolean,
    heater: Boolean,
    maintenenceStaff: Boolean,
    visitorParking: Boolean,
    IntercomFacility: Boolean,
    wifi: Boolean,
    fireAlarm: Boolean,
    WaterPurifier: Boolean,
    PowerBackup: Boolean,
    // highlights
    WaterSupplyFor24Hours: Boolean,
    CloseToSchool: Boolean,
    CloseToHospital: Boolean,
    CloseToRailwayStation: Boolean,
    CloseToBusStand: Boolean,
    CloseToAirport: Boolean,
    CloseToBank: Boolean,
    CloseToPark: Boolean,
    // other details
    status: {
        type: String,
        maxLength: [300, "dont write description overlimit"]
    },
    Address: {
        type: String,
        maxLength: [400, "dont write description overlimit"]
    },
    price: {
        required: [true, 'Required field'],
        type: Number,
        min: [0, "price can not be negative"]
    },
    Advance: {
        type: Number,
        min: [0, "advanve cannot be negative"]
    },
    transactionType: String,
    ageOfProperty: {
        type: String,
        maxLength: [30, "dont write description overlimit"]
    },
    availabilityBy: {
        type: String,
        maxLength: [30, "dont write description overlimit"]
    },
    totalFloors: {
        type: Number,
        min: [0, "total floors cannot be negative"]
    },
    PropertyFloor: {
        type: Number,
        min: [0, "Property floor cannot be negative"]
    },
    propertyArea: {
        type: Number,
        min: [0, "property area cannot be negative"]
    },
    poojaRoom: {
        type: Number,
        min: [0, "pooja room cannot be negative"]
    },
    servantRoonm: {
        type: Number,
        min: [0, "servant room cannot be negative"]
    },
    noofCoveredParking: {
        type: Number,
        min: [0, " No of Covered Parking cannot be negative"]
    },
    noOfOpenParking: {
        type: Number,
        min: [0, "No Of Open Parking cannot be negative"]
    },
    description: {
        type: String,
        maxLength: [300, "dont write description overlimit"]
    },
    imageUrls: String,
    extras: {
        type: String,
        maxLength: [300, "dont write description overlimit"]
    },
    status_wishlist: Boolean
}, { collection: "Property" })


const roleSchema = Schema({
    registeredUsers: [],
    buyers: [],
    sellers: []
}, { collection: "Role" })


const locationSchema = Schema({
    propertyIds: [],
    pincode: Number,
    area: String,
    city: String,
    state: String
}, { collection: "Location" })


//To create user Collection
collection.getUserCollection = () => {
    return Mongoose.connect(url, { useNewUrlParser: true }).then((database) => {
        return database.model('User', userSchema)
    }).catch(() => {
        let err = new Error("Could not connect to Database");
        err.status = 500;
        throw err;
    })
}

//To create Role of user Collection
collection.getRoleCollection = () => {
    return Mongoose.connect(url, { useNewUrlParser: true }).then((database) => {
        return database.model('Role', roleSchema)
    }).catch(() => {
        let err = new Error("Could not connect to Database");
        err.status = 500;
        throw err;
    })
}

//To create Location Collection

collection.getLocationCollection = () => {
    return Mongoose.connect(url, { useNewUrlParser: true }).then((database) => {
        return database.model('Location', locationSchema)
    }).catch(() => {
        let err = new Error("Could not connect to Database");
        err.status = 500;
        throw err;
    })
}

//To create Property Collection
collection.getPropertyCollection = () => {
    return Mongoose.connect(url, { useNewUrlParser: true }).then((database) => {
        return database.model('Property', propertySchema)
    }).catch(() => {
        let err = new Error("Could not connect to Database");
        err.status = 500;
        throw err;
    })
}

module.exports = collection;

ErrorLogger.jsconst fs = require( 'fs' );

let errorLogger = ( err, req, res, next ) => {
    fs.appendFile( './ErrorLogger.txt', err.stack + "\n", ( error ) => {
        if( error ) console.log( "logging error failed" );
    } );
    if( err.status ) res.status( err.status );
    else res.status( 500 );
    res.json( { "message": err.message } )
    next();
}

module.exports = errorLogger;

RequestLogger.js

const fs = require( 'fs' );

let requestLogger = ( req, res, next ) => {
    let logMessage = "" + new Date() + " " + req.method + " " + req.url + "\n";
    fs.appendFile( './RequestLogger.txt', logMessage, ( err ) => {
        if( err ) return next( err );
    } );
    next();

}

module.exports = requestLogger;

Validator.js

let Validator={};



Validator.validateName=(name)=>{
    let nameRegex=/^[a-zA-Z]+( )*[a-zA-Z]*( )*[a-zA-Z]+$/
    if(nameRegex.test(name)){
        return true
    }else{
        let err=new Error("Name does not match");
        err.status=500;
        throw err;
    }
}


Validator.validateEmail =(email)=>{
    let emailRegex = /^[a-z]+[0-9]*@[a-z]+\.([a-z]{2,3})(\.){0,1}([a-z]{0,2})$/
    if(!emailRegex.test(email)){    

        return false;
    }
    else{
        return true;
    }
    
}

Validator.validatePassword=(password)=>{
    let passRegex=/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W).{7,20}$/
    if(!passRegex.test(password)){      
        return false
    }else{
        return true
    }
}

Validator.validateContactNo=(contactNo)=>{
   
}


module.exports = Validator;

App.js

const express = require('express');
const bodyParser = require('body-parser');
const Routing = require('./routes/Routing')
const cors = require("cors")
const create = require('./model/dbsetup')

const app = express();
const errorLogger= require('./utilities/ErrorLogger')
const requestLogger= require('./utilities/RequestLogger')

app.use(cors())
app.use(bodyParser.json());
// to setup the Database
app.get('/setupDb', (req, res, next) => {
    create.setupDb().then((data) => {
        res.send(data)
    }).catch((err) => {
        next(err)
    })
})
app.use(requestLogger)
app.use('/user', Routing)

app.use(errorLogger)
console.log("Server listening in port 3000");
app.listen(3000);


module.exports = app;